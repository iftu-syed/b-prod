const express = require('express');
const path = require('path'); // Add this line to import the path module
const bodyParser = require('body-parser');
const { MongoClient } = require('mongodb');
const app = express();
const PORT = 3088;
const crypto = require('crypto');

// Function to hash the MR number
function hashMrNo(mrNo) {
    return crypto.createHash('sha256').update(mrNo).digest('hex');
}

// Connection URI
const uri = 'mongodb://localhost:27017'; // Change this URI according to your MongoDB setup

app.use(express.static(path.join(__dirname, 'public')));

// Database Name
const dbName = 'Data_Entry_Incoming'; // Change this to your actual database name

// Connection options
const options = {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  // Add more options as needed
};

// Function to connect to the MongoDB database
async function connectToDatabase() {
  let client;
  try {
    // Create a new MongoClient
    client = new MongoClient(uri, options);

    // Connect the client to the server
    await client.connect();

    console.log("Connected successfully to MongoDB server");

    // Specify the database you want to use
    const db = client.db(dbName);

    return db;
  } catch (error) {
    console.error("Error connecting to MongoDB:", error);
    throw error;
  }
}

const uri1 = 'mongodb://localhost:27017/Data_Entry_Incoming';
const uri3 = 'mongodb://localhost:27017/manage_doctors';
let db1, db3;

// Connect to the first database
const client1 = new MongoClient(uri1, { useNewUrlParser: true, useUnifiedTopology: true });
client1.connect();
db1 = client1.db('Data_Entry_Incoming');
console.log('Connected to Data_Entry_Incoming database');

// Connect to the third database
const client3 = new MongoClient(uri3, { useNewUrlParser: true, useUnifiedTopology: true });
client3.connect();
db3 = client3.db('manage_doctors');
console.log('Connected to manage_doctors database');

async function connectToThirdDatabase() {
  let client;
  try {
    // Create a new MongoClient
    client = new MongoClient(uri3, options);

    // Connect the client to the server
    await client.connect();

    console.log("Connected successfully to third database");

    // Specify the database you want to use
    const db = client.db('manage_doctors');

    return db;
  } catch (error) {
    console.error("Error connecting to third database:", error);
    throw error;
  }
}

app.set('view engine', 'ejs');
app.use(bodyParser.urlencoded({ extended: true }));

// Define root route
app.get('/', (req, res) => {
  res.render('search');
});

app.get('/search', async (req, res) => {
  const { identifier } = req.query;
  try {
    const db = await connectToDatabase();
    const collection = db.collection('patient_data');
    const hashedIdentifier = hashMrNo(identifier);
    const patient = await collection.findOne({
      $or: [
        { Mr_no: identifier },
        { phoneNumber: identifier },
        { hashedMrNo: identifier },
        { hashedMrNo: hashedIdentifier }
      ]
    });

    if (!patient) {
      return res.status(404).send('Patient not found');
    }

    res.render('dob-validation', { Mr_no: patient.Mr_no, DOB: patient.DOB });
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal server error');
  }
});

const preprocessSurveyName = (survey) => {
  if (survey === 'ICIQ-UI SF') {
    return 'ICIQ_UI_SF';
  }
  return survey;
};

const getSurveyOrderFromDatabase = async (speciality) => {
  const db3 = await connectToThirdDatabase();
  const surveyData = await db3.collection('surveys').findOne({ specialty: speciality });

  if (!surveyData || !surveyData.surveyName) {
    throw new Error('No surveys found for the given specialty');
  }

  const surveyOrder = surveyData.surveyName.map(preprocessSurveyName);
  console.log("Survey list from database:", surveyOrder);
  return surveyOrder;
};

app.get('/details', async (req, res) => {
  const { Mr_no, DOB } = req.query;

  const isValidDOB = (dob) => {
    const dobRegex = /^\d{2}\/\d{2}\/\d{4}$/;
    return dobRegex.test(dob);
  };

  if (!isValidDOB(DOB)) {
    return res.status(400).send('Invalid DOB format. Please enter DOB in MM/DD/YYYY format.');
  }

  try {
    const db = await connectToDatabase();
    const collection = db.collection('patient_data');
    const patient = await collection.findOne({ Mr_no });

    if (!patient || patient.DOB !== DOB) {
      return res.status(404).send('Patient not found');
    }

    const today = new Date();
    const completedSurveys = {};
    const surveyOrder = await getSurveyOrderFromDatabase(patient.speciality);

    surveyOrder.forEach(survey => {
      const completionDateField = `${survey}_completionDate`;
      if (patient[completionDateField]) {
        const completionDate = new Date(patient[completionDateField]);
        const daysDifference = Math.floor((today - completionDate) / (1000 * 60 * 60 * 24));
        completedSurveys[survey] = daysDifference <= 30;
      }
    });

    res.render('details', { Mr_no, patient, surveyName: surveyOrder, completedSurveys });
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal server error');
  }
});

const getSurveyUrls = (patient, surveyNames) => {
  surveyNames = surveyNames || [];
  return surveyNames.map(survey => `/${survey}?Mr_no=${patient.Mr_no}`);
};

app.get('/start-surveys', async (req, res) => {
  const { Mr_no, DOB } = req.query;
  try {
    const db = await connectToDatabase();
    const collection = db.collection('patient_data');
    const patient = await collection.findOne({ Mr_no });

    if (!patient) {
      return res.status(404).send('Patient not found');
    }

    const surveyOrder = await getSurveyOrderFromDatabase(patient.speciality);
    const surveyUrls = getSurveyUrls(patient, surveyOrder);

    let nextSurveyUrl = null;
    for (const survey of surveyOrder) {
      const completionDateField = `${survey}_completionDate`;
      if (!patient[completionDateField] || patient.surveyStatus === 'Not Completed') {
        nextSurveyUrl = surveyUrls.find(url => url.includes(survey));
        break;
      }
    }

    if (nextSurveyUrl) {
      res.redirect(nextSurveyUrl);
    } else {
      await db1.collection('patient_data').findOneAndUpdate(
        { Mr_no },
        { $set: { surveyStatus: 'Completed' } }
      );
      res.redirect(`/details?Mr_no=${Mr_no}&DOB=${DOB}`);
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal server error');
  }
});

const handleSurveySubmission = async (req, res, collectionName) => {
  const formData = req.body;
  const { Mr_no } = formData;

  try {
    const patientData = await db1.collection('patient_data').findOne({ Mr_no });

    if (patientData) {
      let newIndex = 0;
      if (patientData[collectionName]) {
        newIndex = Object.keys(patientData[collectionName]).length;
      }

      const newKey = `${collectionName}_${newIndex}`;
      formData.timestamp = new Date().toISOString();

      const completionDateField = `${collectionName}_completionDate`;
      const completionDate = new Date().toISOString();

      await db1.collection('patient_data').updateOne(
        { Mr_no },
        {
          $set: {
            [`${collectionName}.${newKey}`]: formData,
            [completionDateField]: completionDate,
            surveyStatus: 'Not Completed'
          }
        }
      );

      const surveyOrder = await getSurveyOrderFromDatabase(patientData.speciality);
      const currentSurveyIndex = surveyOrder.indexOf(collectionName);
      let nextSurveyIndex = currentSurveyIndex + 1;

      if (nextSurveyIndex < surveyOrder.length) {
        const nextSurveyName = surveyOrder[nextSurveyIndex];
        return res.redirect(`/${nextSurveyName}?Mr_no=${Mr_no}`);
      }

      await db1.collection('patient_data').findOneAndUpdate(
        { Mr_no },
        { $set: { surveyStatus: 'Completed' } }
      );
      res.redirect(`/details?Mr_no=${Mr_no}&DOB=${patientData.DOB}`);
    } else {
      console.log('No matching document found for Mr_no:', Mr_no);
      return res.status(404).send('No matching document found');
    }
  } catch (error) {
    console.error('Error updating form data:', error);
    return res.status(500).send('Error updating form data');
  }
};

// Update form submission handlers to call the handleSurveySubmission function
app.post('/submit_Wexner', (req, res) => handleSurveySubmission(req, res, 'Wexner'));
app.post('/submit_ICIQ_UI_SF', (req, res) => handleSurveySubmission(req, res, 'ICIQ_UI_SF'));
app.post('/submitEPDS', (req, res) => handleSurveySubmission(req, res, 'EPDS'));
app.post('/submitPAID', (req, res) => handleSurveySubmission(req, res, 'PAID'));
app.post('/submitPROMIS-10', (req, res) => handleSurveySubmission(req, res, 'PROMIS-10'));

// Handle GET request to display the Wexner form
app.get('/Wexner', (req, res) => {
  const { Mr_no } = req.query;
  res.render('Wexner', { Mr_no });
});

app.get('/ICIQ_UI_SF', (req, res) => {
  const { Mr_no } = req.query;
  res.render('ICIQ_UI_SF', { Mr_no });
});

// Handle GET request to display the EPDS form
app.get('/EPDS', (req, res) => {
  const { Mr_no } = req.query;
  res.render('EPDS', { Mr_no });
});

// Handle GET request to display the PAID form
app.get('/PAID', (req, res) => {
  const { Mr_no } = req.query;
  res.render('PAID', { Mr_no });
});

// Handle GET request to display the PROMIS-10 form
app.get('/PROMIS-10', (req, res) => {
  const { Mr_no } = req.query;
  res.render('PROMIS-10', { Mr_no });
});



app.post('/submit_Wexner', async (req, res) => {
  const formData = req.body;
  const { Mr_no } = formData; // Mr_no passed from the form

  try {
      // Find the document in patient_data collection that matches Mr_no
      const patientData = await db1.collection('patient_data').findOne({ Mr_no });

      if (patientData) {
          // Calculate the index for the new Wexner object
          let newIndex = 0;
          if (patientData['Wexner']) {
              newIndex = Object.keys(patientData['Wexner']).length;
          }

          // Construct the new Wexner object key with the calculated index
          const newICIQ_UI_SFKey = `Wexner_${newIndex}`;

          // Get the current date and time
          const currentDate = new Date();
          const timestamp = currentDate.toISOString(); // Convert to ISO string format

          // Add timestamp to the form data
          formData.timestamp = timestamp;

          // Construct the new Wexner object with the calculated key and form data
          const newICIQ_UI_SF = { [newICIQ_UI_SFKey]: formData };

          // Update the document with the new Wexner object
          await db1.collection('patient_data').updateOne(
              { Mr_no },
              { $set: { [`Wexner.${newICIQ_UI_SFKey}`]: formData } }
          );

          // Send success response
          res.status(200).send(htmlContent);
      } else {
          // If no document found for the given Mr_no
          console.log('No matching document found for Mr_no:', Mr_no);
          return res.status(404).send('No matching document found');
      }
  } catch (error) {
      console.error('Error updating Wexner form data:', error);
      return res.status(500).send('Error updating Wexner form data');
  }
});

app.post('/submit_ICIQ-UI_SF', async (req, res) => {
  const formData = req.body;
  const { Mr_no } = formData; // Mr_no passed from the form

  try {
      // Find the document in patient_data collection that matches Mr_no
      const patientData = await db1.collection('patient_data').findOne({ Mr_no });

      if (patientData) {
          // Calculate the index for the new ICIQ-UI SF object
          let newIndex = 0;
          if (patientData['ICIQ-UI_SF']) {
              newIndex = Object.keys(patientData['ICIQ-UI_SF']).length;
          }

          // Construct the new ICIQ-UI SF object key with the calculated index
          const newICIQ_UI_SFKey = `ICIQ_UI_SF_${newIndex}`;

          // Get the current date and time
          const currentDate = new Date();
          const timestamp = currentDate.toISOString(); // Convert to ISO string format

          // Add timestamp to the form data
          formData.timestamp = timestamp;

          // Construct the new ICIQ-UI SF object with the calculated key and form data
          const newICIQ_UI_SF = { [newICIQ_UI_SFKey]: formData };

          // Update the document with the new ICIQ-UI SF object
          await db1.collection('patient_data').updateOne(
              { Mr_no },
              { $set: { [`ICIQ-UI_SF.${newICIQ_UI_SFKey}`]: formData } }
          );

          // Send success response
          res.status(200).send(htmlContent);
      } else {
          // If no document found for the given Mr_no
          console.log('No matching document found for Mr_no:', Mr_no);
          return res.status(404).send('No matching document found');
      }
  } catch (error) {
      console.error('Error updating ICIQ-UI SF form data:', error);
      return res.status(500).send('Error updating ICIQ-UI SF form data');
  }
});



app.post('/submitEPDS', async (req, res) => {
  const formData = req.body;
  const { Mr_no } = formData; // Mr_no passed from the form

  try {
      // Find the document in patient_data collection that matches Mr_no
      const patientData = await db1.collection('patient_data').findOne({ Mr_no });

      if (patientData) {
          // Calculate the index for the new EPDS object
          let newIndex = 0;
          if (patientData.EPDS) {
              newIndex = Object.keys(patientData.EPDS).length;
          }

          // Construct the new EPDS object key with the calculated index
          const newEPDSKey = `EPDS_${newIndex}`;

          // Get the current date and time
          const currentDate = new Date();
          const timestamp = currentDate.toISOString(); // Convert to ISO string format

          // Add timestamp to the form data
          formData.timestamp = timestamp;

          // Construct the new EPDS object with the calculated key and form data
          const newEPDS = { [newEPDSKey]: formData };

          // Update the document with the new EPDS object
          await db1.collection('patient_data').updateOne(
              { Mr_no },
              { $set: { [`EPDS.${newEPDSKey}`]: formData } }
          );

          // Send success response
          // return res.status(200).send('EPDS object created successfully');
          res.status(200).send(htmlContent);
      } else {
          // If no document found for the given Mr_no
          console.log('No matching document found for Mr_no:', Mr_no);
          return res.status(404).send('No matching document found');
      }
  } catch (error) {
      console.error('Error updating form data:', error);
      return res.status(500).send('Error updating form data');
  }
});


// Handle POST request to submit the PAID form data
app.post('/submitPAID', async (req, res) => {
  const formData = req.body;
  const { Mr_no } = formData; // Mr_no passed from the form

  try {
      // Find the document in patient_data collection that matches Mr_no
      const patientData = await db1.collection('patient_data').findOne({ Mr_no });

      if (patientData) {
          // Calculate the index for the new PAID object
          let newIndex = 0;
          if (patientData.PAID) {
              newIndex = Object.keys(patientData.PAID).length;
          }

          // Construct the new PAID object key with the calculated index
          const newPAIDKey = `PAID_${newIndex}`;

          // Get the current date and time
          const currentDate = new Date();
          const timestamp = currentDate.toISOString(); // Convert to ISO string format

          // Add timestamp to the form data
          formData.timestamp = timestamp;

          // Construct the new PAID object with the calculated key and form data
          const newPAID = { [newPAIDKey]: formData };

          // Update the document with the new PAID object
          await db1.collection('patient_data').updateOne(
              { Mr_no },
              { $set: { [`PAID.${newPAIDKey}`]: formData } }
          );

          // Send success response
          res.status(200).send(htmlContent);
      } else {
          // If no document found for the given Mr_no
          console.log('No matching document found for Mr_no:', Mr_no);
          return res.status(404).send('No matching document found');
      }
  } catch (error) {
      console.error('Error updating PAID form data:', error);
      return res.status(500).send('Error updating PAID form data');
  }
});


app.post('/submitPROMIS-10', async (req, res) => {
  const formData = req.body;
  const { Mr_no } = formData; // Mr_no passed from the form

  try {
    // Find the document in patient_data collection that matches Mr_no
    const patientData = await db1.collection('patient_data').findOne({ Mr_no });

    if (patientData) {
      // Calculate the index for the new PROMIS-10 object
      let newIndex = 0;
      if (patientData['PROMIS-10']) {
        newIndex = Object.keys(patientData['PROMIS-10']).length;
      }

      // Construct the new PROMIS-10 object key with the calculated index
      const newPROMIS10Key = `PROMIS-10_${newIndex}`;

      // Get the current date and time
      const currentDate = new Date();
      const timestamp = currentDate.toISOString(); // Convert to ISO string format

      // Add timestamp to the form data
      formData.timestamp = timestamp;

      // Construct the new PROMIS-10 object with the calculated key and form data
      const newPROMIS10 = { [newPROMIS10Key]: formData };

      // Update the document with the new PROMIS-10 object
      await db1.collection('patient_data').updateOne(
        { Mr_no },
        { $set: { [`PROMIS-10.${newPROMIS10Key}`]: formData } }
      );

      // Send success response
      res.status(200).send(htmlContent);
    } else {
      // If no document found for the given Mr_no
      console.log('No matching document found for Mr_no:', Mr_no);
      return res.status(404).send('No matching document found');
    }
  } catch (error) {
    console.error('Error updating PROMIS-10 form data:', error);
    return res.status(500).send('Error updating PROMIS-10 form data');
  }
});





app.listen(PORT, () => {
  console.log(`The patient surveys flow is running at http://localhost:${PORT}`);
});