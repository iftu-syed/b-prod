<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Entry Form</title>
    <link rel="stylesheet" href="<%= basePath %>/styles.css"> <!-- Correct the path to your CSS file -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <!-- <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'> -->
    <link rel="stylesheet" href="<%= basePath %>/assets/icons/boxicons/css/boxicons.min.css">

    <link rel="stylesheet" href="<%= basePath %>/css/introjs.min.css">

    <style>
        .language-selector {
      text-align: right;
      /* margin: 10px; */
    }

    .language-selector a {
      text-decoration: none;
      margin: 0 10px;
      color: #007BFF;
    }

    .language-selector a.active {
      font-weight: bold;
      text-decoration: underline;
    }
    .language-selector img {
      margin-right: 5px;
      width: 20px;
      margin-left: 5px;
      height: auto;
      vertical-align: bottom;
    }

        /* Existing styles for .form-select */
        .form-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #5F677C;
            border-radius: 5px;
            appearance: none;
            font-weight: lighter;
            background-color: white; /* Ensure background is white */
            color: black; /* Ensure text color is black */
        }

        /* Ensure the dropdown options have a white background with black text */
        .form-select option {
            background-color: white; /* White background for options */
            color: black; /* Black text for options */
        }

        /* Apply styles specifically when the dropdown is expanded */
        .form-select:focus {
            background-color: white; /* White background when dropdown is focused/expanded */
            color: black; /* Black text when dropdown is focused/expanded */
        }

        /* Ensure selected option also has a white background and black text */
        .form-select option:checked {
            background-color: white; /* White background for the selected option */
            color: black; /* Black text for the selected option */
        }

        /* Additional styling for the dropdown arrow */
        .form-select .arrow {
            margin-left: 40px;
            display: inline-block;
            width: 10px;
            height: 10px;
            border-right: 2px solid #131217;
            border-top: 2px solid #131217;
            transform: rotate(45deg);
            transition: transform 0.3s ease;
        }

        .optional-text {
            font-size: smaller; /* Adjust the size as needed */
            color: gray;       /* Optional: Change color for more distinction */
        }

        .csv-upload-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 4px;
        }

        .csv-upload-button:hover {
            background-color: #0056b3;
        }

        #csvFile {
            display: none;
        }

        .introjs-tooltipbuttons {
    text-align: right; /* Align buttons to the right */

}

.help-btn {
    background-color: #007BFF;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 15px;
    cursor: pointer;
    font-size: 16px;
    margin: 0px !important;
    transition: background-color 0.3s ease;
}

.help-btn:hover {
    background-color: #0056b3; /* Slightly darker blue on hover */
}


.help-button-container {
    position: fixed;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #12171e;
  padding: 12px 0;
  transition: all 0.5s ease;
}

/* Ensure the button aligns well with sidebar's active state */
.sidebar.active .help-btn {
    color: #fff;
    display: flex;
    width: 100%;
    gap: 5px;
    align-items: center;
    text-decoration: none;
    border-radius: 0.8rem;
}

.popup {
  display: none; /* Hidden by default */
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0, 0, 0, 0.5);
}

.popup-content {
  display: flex;
  flex-direction: column;
  /* Center horizontally; tweak vertical margin as needed */
  margin: 10% auto;
  width: 75%;
  max-height: 55vh; /* Or 50vh, 52vh, etc. if you prefer */
  position: relative;
  container-type: inline-size; /* For the offset-path/trail animation */
}

/* The content wrapper inside .popup-content.
   This is where your header, body, and footer live.
   We make it flex:1 so it can grow/shrink to fill vertical space,
   letting the .popup-body scroll and the footer stay at bottom.
*/
.content {
  display: flex;
  flex-direction: column;
  flex: 1;   /* Let this fill the space */
  position: relative; /* For safe measure */
  height: 50px;
  border: calc(var(--border-width, 3) * 1px) solid transparent;
  border-radius: calc(var(--border-radius, 16) * 1px);
  background: linear-gradient(
      var(--canvas, #ffffff),
      var(--canvas, #ffffff)
    ) padding-box,
    transparent;
  /* Just some padding if you like */
  padding: 0.5rem;
}

/* 
  Now your existing popup-header, popup-body, and popup-footer 
  remain largely the same, but nested inside .content 
*/
.popup-header {
  padding: 10px;
  border-bottom: 1px solid #ddd;
  /* Tweak styling as needed */
}

.popup-body {
  /* This is the scrollable area */
  flex: 1;               /* Fill remaining vertical space */
  overflow-y: auto;      /* Enable vertical scrolling */
  padding: 10px;
  white-space: nowrap;   /* Keep table from wrapping */
}

.popup-footer {
  position: sticky;
  bottom: 0;
  background-color: #fefefe;
  border-top: 1px solid #ddd;
  padding: 10px;
  z-index: 1; /* So it stays above the scrolling content */
  
  display: flex;
  justify-content: center; 
  align-items: center;
  position: relative; /* needed for absolute-positioned .Btn-desc */
}

/* The left-side text in the footer */
.Btn-desc {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  max-width: 340px;
}

.skip-desc,
.cancel-desc {
  color: #5F677C;
  font-size: small;
  font-weight: bold;
  margin: 0 0 5px; 
}

/* Buttons area in the footer */
.popup-buttons {
  display: inline-flex; 
  gap: 10px;
}

.skip-btn {
  background-color: #28a745; 
  color: white;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  font-size: 14px;
}
.skip-btn:hover {
  background-color: #218838;
}

.download-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    background-color: #6c757d; /* Gray */
    color: white;
  }
  .download-btn:hover {
    background-color: #5a6268; /* Darker gray */
  }

.cancel-btn {
  background-color: #dc3545; 
  color: white;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  font-size: 14px;
}
.cancel-btn:hover {
  background-color: #c82333;
}

/* Table styling */
table {
  border-collapse: collapse;
  width: 100%;          
  min-width: 1000px; /* Force horizontal scrolling if narrower */
}
table th, table td {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: center;
  font-size: 14px;
}
.missing-field {
  color: #d8000c;
  border-radius: 3px;
  padding: 4px;
  text-align: center;
}

/******************************************/
/* 2) The Border + Trail Effect           */
/******************************************/

/* The big background perimeter behind .content */
.border {
  position: absolute;
  inset: 0;
  border-radius: calc(var(--border-radius, 16) * 1px);
  clip-path: inset(0 0 0 0 round calc(var(--border-radius, 16) * 1px));
  background: var(--border, #aaa); 
  z-index: -1; /* behind .content */
  border: 0;
  container-type: inline-size;
}

/* The traveling radial dot along the perimeter */
.trail {
  width: calc(var(--trail-size, 20) * 1cqmin); /* can use px if you prefer */
  aspect-ratio: 2 / 1;
  position: absolute;
  background: radial-gradient(
    100% 100% at right,
    var(--accent, red),
    transparent 50%
  );
  offset-path: border-box; /* key to follow the “border” perimeter */
  offset-anchor: 100% 50%;
  animation: journey var(--speed, 6s) infinite linear;
}

/* Slower if the container is big */
@container (width > 600px) {
  .trail {
    --speed: 12s;
  }
}

@keyframes journey {
  to {
    offset-distance: 100%;
  }
}

/******************************************/
/* 3) (Optional) 3D "explode" transitions */
/******************************************/
[data-explode="true"] .popup-content {
  transition: transform 0.7s;
  transform: scale(0.8) rotateX(-20deg) rotateY(30deg);
}

[data-explode="true"] .content {
  transition: 
    transform 0.7s 0.3s, 
    opacity 0.5s 0.3s;
  transform: translate3d(0, 0, 400px);
  opacity: 0;
}


.flash-message {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%); /* Center horizontally */
    background-color: #4CAF50; /* Green for success */
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    font-size: 16px;
    z-index: 1000;
}

.flash-error-message{
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%); /* Center horizontally */
    background-color: #f32727; /* Green for success */
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    font-size: 16px;
    z-index: 1000;
}
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="top">
            <div class="logo">
                <img src="<%= basePath %>/assets/images/logo_white.png" alt="WeHealthify">
            </div>
            <i class="bx bx-menu" id="btn"></i>
        </div>
        <br>
        <div class="sidebar-footer">
            <p id="staffLabel" class="bold">Staff</p>
            <p class="bold"><%= doctor.hospitalName %></p><!-- Updated here -->
            <p class="bold"><%= doctor.site_code %></p>   <!-- Updated here -->
        </div>
        <ul>
            <li>
                <a href="<%= basePath %>/blank-page">
                    <i class="bx bxs-grid-alt"></i>
                    <span class="nav-item" id="dashboardLabel">Dashboard</span>
                </a>
                <span class="tooltip" id="dashboardTooltip">Dashboard</span>
            </li>
            <li>
                <a href="<%= basePath %>/data-entry">
                    <i class='bx bx-plus-circle'></i>
                    <span class="nav-item" id="addAppointmentLabel">Add Appointment</span>
                </a>
                <span class="tooltip" id="addAppointmentTooltip">Add Appointment</span>
            </li> 
            <li>
                <a href="<%= basePath %>/logout">
                    <i class="bx bx-log-out"></i>
                    <span class="nav-item" id="logoutLabel">Logout</span>
                </a>
                <span class="tooltip" id="logoutTooltip">Logout</span>
            </li>            
        </ul>

        <div class="help-button-container">
            <button id="helpButton" class="help-btn">
                <span class="nav-item" id="helpLabel">Help </span>
                <i class='bx bx-help-circle'></i>
            </button>
            
        
        </div>
    </div>

    <div class="main-content">
        <div class="topbar" dir="<%= lng === 'ar' ? 'rtl' : 'ltr' %>">
            <!-- <h1>Add Appointment</h1>  -->
            <h2 id="welcomeMessage" style="color: #333333;">Welcome, <%= doctor.firstName %> <%= doctor.lastName %></h2> <!-- Updated here -->
        </div>
        <hr style="opacity: 0.5;">
        <div class="language-selector" style="text-align: right; padding: 10px; background-color: #f6f5fa;">
            <a href="?lng=en" class="<%= lng === 'en' ? 'active' : '' %>">
                <img src="<%= basePath %>/assets/usa.png" alt="English Flag">English
            </a> |
            <a href="?lng=ar" class="<%= lng === 'ar' ? 'active' : '' %>">
                <img src="<%= basePath %>/assets/flag.png" alt="Arabic Flag">العربية
            </a>
          </div>   

        <div class="csv-upload-container" dir="<%= lng === 'ar' ? 'rtl' : 'ltr' %>">
            <div class="main-container" data-title="Form" data-intro="Enter details of patient for appointment creation.">
                <div class="topContainer">
                    <br><br><h2 id="dataEntryFormTitle" style="text-align: center; margin-bottom: 20px; color: #333333;">Data Entry Form</h2>
                </div>
                
                <!-- image -->
                <div class="container">
                    <div class="left-section">
                        <h4 id="batchAppointmentsTitle">Batch Appointments</h4>
                        <form id="csvUploadForm" class="upload-area" method="POST" action="<%= basePath %>/api/upload-csv" enctype="multipart/form-data" style="position: relative;">
                            <i class='bx bx-upload' style='font-size: 60px;'></i>
                            <p id="selectCSVFileText"><b>Select a CSV file to upload</b><br>or drag and drop it here</p>
                            <input type="file" id="csvFile" name="csvFile" accept=".csv" required>
                        </form>  

                        <div id="progress-container" style="display: none;">
                            <progress id="upload-progress" value="0" max="100"></progress>
                            <span id="progress-text">0%</span>
                        </div>
                        
                        <a href="<%= basePath %>/patient_data_template.csv"><span id="csvTemplateLinkText"><b>Find CSV Template Here</b></span></a>
                        <div style="text-align: center;">
                            <button id="uploadCSVButton" type="button" class="upload-btn" onclick="document.getElementById('csvFile').click()"><i class='bx bx-upload'></i> Upload CSV</button>
                        </div>
                    </div>

                    <hr>
                    <div class="middle-section">
                        <h4 id="singleAppointmentsTitle">Single Appointments</h4>
                        <form id="dataForm" method="POST" action="<%= basePath %>/api/data">
                            <div class="form-group">
                                <label for="Mr_no" class="form-label">MR Number</label>
                                <input type="text" id="Mr_no" class="form-input" name="Mr_no" required>
                            </div>
                            <div class="form-group">
                                <label id="firstNameLabel" for="firstName" class="form-label">First Name:</label>
                                <input type="text" id="firstName" class="form-input" name="firstName" required>
                            </div>
                            <div class="form-group">
                                <label for="middleName" id="middleNameLabel" class="form-label">Middle Name (Optional):</label>
                                <input type="text" id="middleName" class="form-input" name="middleName">
                            </div>
                            <div class="form-group">
                                <label for="lastName" id="lastNameLabel" class="form-label">Last Name:</label>
                                <input type="text" id="lastName" class="form-input" name="lastName" required>
                            </div>
                            <!-- <div class="form-group">
                                <label for="lastName" id="genderLabel" class="form-label">Gender</label>
                                <input type="text" id="lastName" class="form-input" name="gender" required>
                            </div> -->
                            <div class="form-group">
                                <label for="gender-select" id="genderLabel" class="form-label">Gender</label>                            
                                    <select id="gender-select" class="form-input" name="gender" required>
                                        <option value="" hidden>Select Gender</option>
                                        <option value="male">Male</option>
                                        <option value="female">Female</option>
                                        <option value="other">Other</option>
                                    </select>
                            </div>
                    </div>

                    <div class="right-section">
                        <h4> <pre> </pre></h4>
                        <div class="form-group">
                            <label for="DOB" id="dobLabel" class="form-label">Date of Birth:</label>
                            <input type="text" class="form-input" id="DOB" name="DOB" required>
                        </div>
                        <div class="form-group">
                            <label for="phoneNumber" id="phoneNumberLabel" class="form-label">Phone Number</label>
                            <input type="tel" id="phoneNumber" class="form-input" name="phoneNumber" required>
                        </div>

                        <div class="form-group">
                            <label for="email" id="emailLabel" class="form-label">Email</label>
                            <input type="email" id="email" class="form-input" name="email" required>
                        </div>

                        <div class="form-group" data-title="Time" data-intro="Set appointment time">
                            <label for="datetime" id="appointmentDateTimeLabel" class="form-label">Appointment Date & Time</label>
                            <input type="datetime-local" id="datetime" class="form-input" name="datetime" required>
                        </div>
                        <div class="form-group" data-title="Doctor" data-intro="Assign a doctor">
                            <label for="speciality-doctor" id="doctorLabel" class="form-label">Doctor</label>
                            <select id="speciality-doctor" class="form-select" name="speciality-doctor" required>
                                <option id="selectDoctorOption" value="">Select Doctor</option>
                                <!-- Options will be dynamically populated here -->
                            </select>
                        </div>

                        <input type="hidden" id="hospitalCode" name="hospital_code" value="<%= hospital_code %>">
                        <input type="hidden" name="site_code" value="<%= site_code %>"> <!-- Add this line -->
                        <input type="hidden" name="surveyStatus" value="Not Completed"> 
                        
                        <button type="submit" class="submit-btn" id="submitButton" data-title="Submit" data-intro="Submitting the details will create an appointment"><i class='bx bx-check-double'></i> Submit</button>
                    </form>
                </div>
            </div>
            <% if (successMessage) { %>
                <div class="success-message">
                    <%= successMessage %>
                </div>
            <% } %>
            <% if (errorMessage) { %>
                <div class="error-message">
                    <%= errorMessage %>
                </div>
            <% } %>            
        </div>
    </div>
    <div id="flashMessageContainer" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #f44336; color: white; padding: 15px; border-radius: 5px; z-index: 1000; font-family: Arial, sans-serif;">
    </div>
    <div id="popup" class="popup">
        <div class="popup-content fluid" data-explode="false">
          <!-- The "border" shape behind, plus the moving "trail" dot -->
          <div class="border">
            <div class="trail"></div>
          </div>
      
          <!-- Wrap your actual popup fields in .content -->
          <div class="content">
            <!-- Popup Header -->
            <div class="popup-header">
              <h2 id="missingFields" dir="<%= lng === 'ar' ? 'rtl' : 'ltr' %>">Missing Fields</h2>
            </div>
      
            <!-- Scrollable Body -->
            <div class="popup-body">
              <div>
                <table
                  border="1"
                  style="width: 100%; border-collapse: collapse;"
                  dir="<%= lng === 'ar' ? 'rtl' : 'ltr' %>"
                >
                  <thead>
                    <tr>
                        <th>Row</th>
                        <th>Mr Number</th>
                        <th>First Name</th>
                        <th>Last Name</th>
                        <th>DOB</th>
                        <th>Appointment Date & Time</th>
                        <th>Specialty</th>
                        <th>Doctor ID</th>
                        <th>PhoneNumber</th>
                        <th>Email</th>
                        <th>Gender</th>
                    </tr>
                  </thead>
                  <tbody id="missing-fields-table"></tbody>
                </table>
              </div>
            </div>
      
            <!-- Buttons Footer (sticky) -->
            <div class="popup-footer">
              <div class="Btn-desc">
                <p class="skip-desc" id="pop-up-p1">
                  *Data for the above patients will not be saved if skipped.
                </p>
                <p class="cancel-desc" id="pop-up-p2">
                  *Upon cancel the entire batch upload will be terminated
                </p>
              </div>
              <div class="popup-buttons">
                <button class="skip-btn" id="uploadButton" onclick="handleSkip()">Skip & Continue</button>
                <button id="downloadCSVButton" class="btn btn-primary download-btn">Download Missing Data CSV</button>
                <button class="cancel-btn" id="cancelButton" onclick="handleCancel()">
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

    <!-- Confirmation message -->
    <div id="confirmationMessage" style="display: none;">Data Entry is done.</div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const getCookie = (name) => {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    };
    const params = new URLSearchParams(window.location.search);
    let currentLanguage = params.get('lng') || getCookie('lng') || 'en';
    
    // Set the language cookie
    document.cookie = `lng=${currentLanguage}; path=/`;
          const fetchUrl = `/staff/locales/${currentLanguage}/translation.json`;
    
      
          // Set the `lang` and `dir` attributes for the HTML document
         
      
          fetch(fetchUrl)
            .then(response => {
              if (!response.ok) {
                console.warn(`Translation file not found for language: ${currentLanguage}. Falling back to English.`);
                return fetch(`/staff/locales/en/translation.json`);
              }
              return response.json();
            })
            .then(translations => {
              console.log('Loaded translations:', translations);
      
              // Update the elements based on translation keys
              Object.keys(translations).forEach(id => {
                const element = document.getElementById(id);
      
                if (element) {
                    const translationValue = translations[id];
    
                    if (typeof translationValue === 'string') {
                        // Update regular text or HTML content
                        element.innerHTML = translationValue;
                    }
                      if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
    
                        // Update placeholders for input elements
    
                        console.log(`Updating placeholder for ${id}:`, translationValue);
    
                        element.placeholder = translationValue;
    
                      }
                    else if (typeof translationValue === 'object') {
                                            // Handle nested object (e.g., lists)
                                            element.innerHTML = ''; // Clear existing content
                                            Object.values(translationValue).forEach(item => {
                                                const listItem = document.createElement('li');
                                                listItem.textContent = item;
                                                element.appendChild(listItem);
                                            });
                    } else {
                        console.warn(`Unexpected translation value type for "${id}":`, translationValue);
                    }
                }
              });
            })
            .catch(error => console.error('Error loading translations:', error));
        });
      </script>
    <!-- Include Flatpickr library -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/en.js"></script>
    <script>
        // Initialize Flatpickr for datetime with custom minute increments and 12-hour time format
        flatpickr("#datetime", {
            enableTime: true,
            dateFormat: "Y-m-d h:i K", // Store the value in 12-hour format with AM/PM
            time_24hr: false, // Use 12-hour format with AM/PM
            minuteIncrement: 15, // Set minute increments to 15 (00, 15, 30, 45)
            minDate: "today", // Disable past dates and times
            altInput: true, // Use an alternative input for displaying the formatted date
            altFormat: "F j, Y h:i K", // Display format for the alternative input (12-hour time with AM/PM)
            defaultHour: 12, // Set default hour to 12 PM
        });

        // Initialize Flatpickr for DOB with custom format
        flatpickr("#DOB", {
            dateFormat: "m/d/Y", // Store the value in MM/DD/YYYY format
            maxDate: "today", // Disable future dates
            altInput: true, // Use an alternative input for displaying the formatted date
            altFormat: "m/d/Y", // Display format for the alternative input
        });

    //     document.getElementById('Mr_no').addEventListener('change', function() {
    //         var mrNo = this.value;
    //         if (mrNo) {
    //             // Fetch patient data
    //             fetch(`<%= basePath %>/api/patient/${mrNo}`)
    //                 .then(response => response.json())
    //                 .then(patientData => {
    //                     if (patientData.success) {
    //                         const patient = patientData.patient;

    //                         // Populate the form fields with the returned data
    //                         document.getElementById('firstName').value = patient.firstName || '';
    //                         document.getElementById('middleName').value = patient.middleName || '';
    //                         document.getElementById('lastName').value = patient.lastName || '';

    //                         // Set the DOB in the input and update Flatpickr
    //                         const dobInput = document.getElementById('DOB');
    //                         dobInput.value = patient.DOB || '';
    //                         if (patient.DOB) {
    //                             flatpickr(dobInput, {
    //                                 dateFormat: "m/d/Y",
    //                                 defaultDate: patient.DOB
    //                             });
    //                         }

    //                         document.getElementById('phoneNumber').value = patient.phoneNumber || '';
    //                         document.getElementById('email').value = patient.email || '';
    //                     } else {
    //                         alert('Patient not found.');
    //                     }
    //                 })
    //                 .catch(error => console.error('Error fetching patient data:', error));
    //         }
    //     });
    // 
    
    document.getElementById('Mr_no').addEventListener('change', function() {
    var mrNo = this.value;
    if (mrNo) {
        // Fetch patient data
        fetch(`<%= basePath %>/api/patient/${mrNo}`)
            .then(response => response.json())
            .then(patientData => {
                if (patientData.success) {
                    const patient = patientData.patient;

                    // Populate the form fields with the returned data
                    document.getElementById('firstName').value = patient.firstName || '';
                    document.getElementById('middleName').value = patient.middleName || '';
                    document.getElementById('lastName').value = patient.lastName || '';

                    // Set the DOB in the input and update Flatpickr
                    const dobInput = document.getElementById('DOB');
                    dobInput.value = patient.DOB || '';
                    if (patient.DOB) {
                        flatpickr(dobInput, {
                            dateFormat: "m/d/Y",
                            defaultDate: patient.DOB
                        });
                    }

                    document.getElementById('phoneNumber').value = patient.phoneNumber || '';
                    document.getElementById('email').value = patient.email || '';

                    // Populate the gender dropdown
                    const genderSelect = document.getElementById('gender-select');
                    if (patient.gender) {
                        // Normalize the gender input to lowercase for matching
                        const genderValue = patient.gender.toLowerCase();
                        for (let option of genderSelect.options) {
                            if (option.value === genderValue) {
                                genderSelect.value = genderValue;
                                break;
                            }
                        }
                    } else {
                        genderSelect.value = ''; // Reset if gender is not available
                    }

                } else {
                    alert('Patient not found.');
                }
            })
            .catch(error => console.error('Error fetching patient data:', error));
    }
});

    </script>
    <script src="<%= basePath %>/js/intro.min.js"></script>
    <script>
        document.getElementById('helpButton').addEventListener('click', function () {
    // Determine the current language (default to English)
    const lang = new URLSearchParams(window.location.search).get('lng') || getCookie('lng') || 'en';

    // Define translations for the steps
    const translations = {
        en: {
            step1: "Enter details of the patient for appointment creation.",
            step2: "Set the appointment time.",
            step3: "Assign a doctor to the appointment.",
            step4: "Submit the details to create the appointment."
        },
        ar: {
            step1: "أدخل تفاصيل المريض لإنشاء موعد.",
            step2: "حدد وقت الموعد.",
            step3: "قم بتعيين طبيب للموعد.",
            step4: "أرسل التفاصيل لإنشاء الموعد."
        }
    };

    // Define the steps for Intro.js
    const introSteps = [
        {
            element: '.main-container', // Form container
            intro: translations[lang].step1
        },
        {
            element: '.form-group[data-title="Time"]', // Appointment date & time input
            intro: translations[lang].step2
        },
        {
            element: '#speciality-doctor', // Doctor dropdown
            intro: translations[lang].step3
        },
        {
            element: '#submitButton', // Submit button
            intro: translations[lang].step4
        }
    ];

    // Initialize and start Intro.js with dynamic labels for buttons
    introJs()
        .setOptions({
            steps: introSteps,
            rtl: lang === 'ar', // Enable RTL if the language is Arabic
            nextLabel: lang === 'ar' ? 'التالي' : 'Next',
            prevLabel: lang === 'ar' ? 'السابق' : 'Back',
            doneLabel: lang === 'ar' ? 'تم' : 'Done'
        })
        .start();
});

// Helper function to retrieve a cookie value by name
function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
}

        
    </script>

    <script>
        let btn = document.querySelector('#btn');
        let sidebar = document.querySelector('.sidebar');
        
        btn.onclick = function() {
            sidebar.classList.toggle('active');
        };
        
        // Show the loading GIF when the form is submitted
        document.querySelectorAll('form').forEach(form => {
            form.addEventListener('submit', function() {
                document.getElementById('loadingContainer').style.display = 'flex';
            });
        });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sidebarLinks = document.querySelectorAll('.sidebar ul li a');

            function removeCurrentPageClasses() {
                sidebarLinks.forEach(link => {
                    link.classList.remove('CurrentPage');
                });
            }

            function setCurrentPageLink(path) {
                removeCurrentPageClasses();
                console.log(`Setting CurrentPage link for path: ${path}`);
                const currentPageLink = Array.from(sidebarLinks).find(link => {
                    const linkPath = new URL(link.href).pathname;
                    return linkPath === path;
                });
                if (currentPageLink) {
                    console.log(`CurrentPage link found: ${currentPageLink.href}`);
                    currentPageLink.classList.add('CurrentPage');
                } else {
                    console.log(`No CurrentPage link found for path: ${path}`);
                }
            }

            // Check the URL path and set the current page link on page load
            const currentPath = window.location.pathname;
            console.log(`Current path: ${currentPath}`);
            setCurrentPageLink(currentPath);

            sidebarLinks.forEach(link => {
                link.addEventListener('click', function() {
                    const targetPath = new URL(link.href).pathname;
                    console.log(`Navigating to: ${targetPath}`);
                    setCurrentPageLink(targetPath);
                });
            });
        });
        setTimeout(() => {
            document.querySelectorAll('.success-message, .error-message').forEach(message => {
                message.style.display = 'none';
            });
        }, 3000); // Hide the message after 3 seconds
    </script>

    <script>
        // Populate the combined dropdown on page load
        document.addEventListener('DOMContentLoaded', function() {
            const hospital_code = "<%= hospital_code %>"; // Get the hospital_code from the session
            const site_code = "<%= site_code %>"; // Get the site_code from the session
            
            // Fetch all specialities and their respective doctors
            fetch(`<%= basePath %>/api/specialties-doctors?hospital_code=${hospital_code}&site_code=${site_code}`)
                .then(response => response.json())
                .then(data => {
                    const selectElement = document.getElementById('speciality-doctor');
                    if (data.success) {
                        data.specialties.forEach(speciality => {
                            // Create an optgroup for each specialty
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = speciality.name;

                            speciality.doctors.forEach(doctor => {
                                const option = document.createElement('option');
                                option.value = `${speciality.name}||${doctor.doctor_id}`;  // Store both specialty and doctor in value
                                option.textContent = doctor.doctor_id; // Display doctor ID
                                optgroup.appendChild(option);
                            });

                            selectElement.appendChild(optgroup);
                        });
                    } else {
                        alert('No specialities or doctors found.');
                    }
                })
                .catch(error => console.error('Error fetching specialties and doctors:', error));
        });

        // On form submission, parse the selected value to extract specialty and doctor
        document.querySelector('form').addEventListener('submit', function(event) {
            const combinedValue = document.getElementById('speciality-doctor').value;
            if (combinedValue) {
                const [speciality, doctor] = combinedValue.split('||');
                
                // Append hidden fields to store extracted specialty and doctor names
                const specialityInput = document.createElement('input');
                specialityInput.type = 'hidden';
                specialityInput.name = 'speciality';
                specialityInput.value = speciality;
        
                const doctorInput = document.createElement('input');
                doctorInput.type = 'hidden';
                doctorInput.name = 'doctor';
                doctorInput.value = doctor;
        
                this.appendChild(specialityInput);
                this.appendChild(doctorInput);
            }
        });
    </script>

<script>
    // flash message script
    const uploadArea = document.getElementById("csvUploadForm");
    const fileInput = document.getElementById("csvFile");
    let isUploading = false; // Prevent duplicate uploads

async function handleFileUpload(file) {
    if (!file || isUploading) return;

    isUploading = true;
    const maxRows = 20000;


    // Read the CSV file to count rows
    const text = await file.text();
    const rows = text.split(/\r?\n/).filter(row => row.trim() !== ''); // Split by newline and filter out empty lines

    if (rows.length - 1 > maxRows) { // Subtract 1 for the header row
        showFlashMessage(`Maximum 1000 patients allowed. Your file contains ${rows.length - 1} rows.`, 'error');
        isUploading = false;
        return;
    }
    
    
    const progressBar = document.getElementById("upload-progress");
    const progressContainer = document.getElementById("progress-container");
    const progressText = document.getElementById("progress-text");
    
    // Reset progress
    progressBar.value = 0;
    progressText.textContent = "0%";
    progressContainer.style.display = "block";

    let artificialProgress = 0;
    let progressInterval;

    // Function to simulate progress
    const simulateProgress = () => {
        if (artificialProgress < 90) {  // Only simulate up to 90%
            // Calculate next progress step
            const increment = Math.random() * 3 + 1; // Random increment between 1-4
            artificialProgress = Math.min(artificialProgress + increment, 90);
            
            // Update progress bar
            progressBar.value = artificialProgress;
            progressText.textContent = `${Math.round(artificialProgress)}%`;
        }
    };

    try {
        if (file.name.endsWith(".csv")) {
            const formData = new FormData();
            const hospitalCode = document.getElementById("hospitalCode").value; 
            formData.append("csvFile", file);
            formData.append("hospital_code", hospitalCode)

            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();

                // Start progress simulation
                progressInterval = setInterval(simulateProgress, 200); // Update every 200ms

                xhr.upload.addEventListener("progress", (event) => {
                    if (event.lengthComputable) {
                        // Clear simulated progress if we get actual progress
                        if (progressInterval) {
                            clearInterval(progressInterval);
                            progressInterval = null;
                        }

                        const actualProgress = Math.min(Math.round((event.loaded / event.total) * 100), 99);
                        
                        // Don't go backwards in progress
                        if (actualProgress > artificialProgress) {
                            artificialProgress = actualProgress;
                            progressBar.value = artificialProgress;
                            progressText.textContent = `${artificialProgress}%`;
                        }
                    }
                });

                // xhr.addEventListener("load", async () => {
                //     // Clear interval if it's still running
                //     if (progressInterval) {
                //         clearInterval(progressInterval);
                //         progressInterval = null;
                //     }

                //     try {
                //         const response = JSON.parse(xhr.responseText);

                //         if (xhr.status === 200) {
                //             if (response.redirectUrl) {
                //         window.location.href = response.redirectUrl; // Perform redirection
                //     } else {
                //         resolve(response);
                //     }
                //             // Smoothly show 100%
                //             progressBar.value = 100;
                //             progressText.textContent = "100%";
                            
                //                                     setTimeout(() => {
                //             // Hide the progress container
                //             progressContainer.style.display = "none";

                //             // Show a flash message
                //             const flashMessage = document.createElement("div");
                //             flashMessage.className = "flash-message";
                //             flashMessage.textContent = response.message || "Batch uploaded successfully!";

                //             // Append the flash message to the body
                //             document.body.appendChild(flashMessage);

                //             // Automatically remove the flash message after 3 seconds
                //             setTimeout(() => {
                //                 flashMessage.remove();
                //             }, 5000);
                //         }, 500);

                //     // Handle the invalid DOB change error
                //                         if (response.invalidEntries && response.invalidEntries.length > 0) {
                //         const errorMessages = response.invalidEntries.map(entry => `Row ${entry.row}: ${entry.error}`);
                //         if (errorMessages.length > 0) {
                //             showFlashMessage("Invalid Entries Detected:\n" + errorMessages.join("\n"), "error");
                //             return;
                //         }
                //     }

                //         } else if (response.missingData?.length > 0) {
                //             progressContainer.style.display = "none";
                //             showPopup(response.missingData);
                //         } else if (response.duplicates?.length > 0) {
                //             progressContainer.style.display = "none";
                //             const userChoice = confirm(
                //                 `Duplicate records found: ${response.duplicates.length}. Do you want to continue?`
                //             );
                //             if (!userChoice) alert("Upload canceled due to duplicates.");
                //         } else {
                //             progressContainer.style.display = "none";
                //             alert("Error: " + (response.error || "Something went wrong."));
                //         }
                //         resolve(response);
                //     } catch (error) {
                //         progressContainer.style.display = "none";
                //         alert("Error in server response.");
                //         reject(error);
                //     }
                // });
    xhr.addEventListener("load", async () => {
    if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
    }

    try {
        const response = JSON.parse(xhr.responseText);

        // Ensure progress bar is set to 100% even if there's an error
        progressBar.value = 100;
        progressText.textContent = "100%";
        progressContainer.style.display = "none";
        const invalidDoctorsData=[];

        // Check if invalidDoctorsData exists
        // if (response.invalidDoctorsData && response.invalidDoctorsData.length > 0) {
        //     showFlashMessage("Invalid Data","error");
        //     console.log("Invalid Doctors Data:", response.invalidDoctorsData);
        //     return; // Stop further execution
        // }
                if (response.invalidDoctorsData && response.invalidDoctorsData.length > 0) {
            // Map through invalidDoctorsData to generate detailed messages for each row
            const errorMessages = response.invalidDoctorsData
                .map(data => `Row ${data.rowNumber}: ${data.error}`)
                .join("\n");

            // Show all error messages in the flash message
            showFlashMessage(`Invalid Data:\n${errorMessages}`, "error");

            // Optionally, log all invalid data to the console
            console.log("Invalid Doctors Data:", response.invalidDoctorsData);

            return; // Stop further execution
        }

        // Check for invalid DOB changes (invalidEntries)
        if (response.invalidEntries && response.invalidEntries.length > 0) {
            const dobErrors = response.invalidEntries.filter(entry => entry.error === "DOB cannot be changed for existing patient");
            // if (dobErrors.length > 0) {
            //     const errorMessages = dobErrors.map(entry => `Row ${entry.row}`).join(",");
            //     showFlashMessage(`Invalid DOB Detected:\n${errorMessages}`, "error");
            //     return; // Stop further execution
            // }
            const duplicateMessages = response.invalidEntries
                .map(info => `Row ${info.rowNumber}: ${info.error}`)
                .join("\n");
                showFlashMessage(`${duplicateMessages}`,"error");
                return; // Stop further execution
        }

        // Handle other errors (e.g., missing data, duplicates)
        if (response.missingData && response.missingData.length > 0) {
            progressContainer.style.display = "none";
            showPopup(response.missingData);
            return; // Stop further execution
        }

        if (response.duplicates && response.duplicates.length > 0) {
            const duplicateMessages = response.duplicates
                .map(info => `Row ${info.rowNumber}: ${info.error}`)
                .join("\n");
                showFlashMessage(`${duplicateMessages}`,"error");
                return; // Stop further execution
        }
        // Show success message if no errors exist
        if (response.redirectUrl) {
            window.location.href = response.redirectUrl; // Redirect if provided
        } else {
            showFlashMessage("Batch uploaded successfully!", "success");
        }
    } catch (error) {
        console.error("Error parsing server response:", error);
        showFlashMessage("An error occurred while processing the upload.", "error");
    }
});


                xhr.addEventListener("error", () => {
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }
                    progressContainer.style.display = "none";
                    alert("An error occurred during file upload.");
                    reject(new Error("Upload failed"));
                });

                xhr.addEventListener("abort", () => {
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }
                    progressContainer.style.display = "none";
                    alert("File upload was canceled.");
                    reject(new Error("Upload aborted"));
                });

                xhr.open("POST", "/staff/data-entry/upload", true);
                xhr.send(formData);
            });
        } else {
            progressContainer.style.display = "none";
            alert("Invalid file type. Please upload a CSV file.");
        }
    } catch (error) {
        if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
        }
        console.error("Error during file upload:", error);
        progressContainer.style.display = "none";
        alert("An error occurred while uploading the file.");
    } finally {
        isUploading = false;
        resetUploadArea();
    }
}


// Add the CSS for smooth progress bar animation
const style = document.createElement('style');
style.textContent = `
    #upload-progress {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 15px;
        border-radius: 10px;
        background: #f0f0f0;
        outline: none;
    }

    #upload-progress::-webkit-progress-bar {
        background: #f0f0f0;
        border-radius: 5px;
    }

    #upload-progress::-webkit-progress-value {
        background: #007bff;
        border-radius: 5px;
        transition: width 1s ease-in-out;
    }

    #upload-progress::-moz-progress-bar {
        background: #007bff;
        border-radius: 5px;
        transition: width 0.3s ease-in-out;
    }

    #progress-text {
        display: block;
        text-align: center;
        margin-top: 5px;
        font-size: 14px;
    }
`;
document.head.appendChild(style);

    // Reset the upload area styles
    function resetUploadArea() {
        uploadArea.style.border = "none";
        uploadArea.style.backgroundColor = "transparent";
    }

    // Handle drag-and-drop file upload
    uploadArea.addEventListener("dragover", (event) => {
        event.preventDefault();
        uploadArea.style.border = "2px dashed #666";
        uploadArea.style.backgroundColor = "#f0f8ff";
    });

    uploadArea.addEventListener("dragleave", resetUploadArea);

    uploadArea.addEventListener("drop", (event) => {
        event.preventDefault();
        resetUploadArea();
        const files = event.dataTransfer.files;
        if (files.length > 0) {
            handleFileUpload(files[0]); // Pass the dropped file for upload
        }
    });

    // Handle upload button click (trigger file input)
    uploadArea.addEventListener("click", () => {
        fileInput.click();
    });

    // Handle file input change (file selection)
    fileInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        handleFileUpload(file); // Pass the selected file for upload
    });


// Handle drag and drop
uploadArea.addEventListener("drop", (event) => {
    event.preventDefault();
    resetUploadArea();

    const files = event.dataTransfer.files;
    if (files.length > 0) {
        currentFile = files[0]; // Store the dropped file
        const dataTransfer = new DataTransfer();
        dataTransfer.items.add(currentFile);
        fileInput.files = dataTransfer.files; // Update the file input element
        showFlashMessage(`File "${currentFile.name}" selected for upload.`, "info");
        function showFlashMessage(message, type = "success") {
    const flashMessage = document.createElement("div");
    flashMessage.className = `flash-message ${type}`;
    flashMessage.innerHTML = message;

    document.body.appendChild(flashMessage);

    // Automatically remove flash message after 5 seconds
    setTimeout(() => {
        flashMessage.remove();
    }, 5000);
}


    }
});

// Function to reset drag-and-drop styling
function resetUploadArea() {
    uploadArea.style.border = "none";
    uploadArea.style.backgroundColor = "transparent";
}

// Handle file input selection
fileInput.addEventListener("change", (event) => {
    currentFile = event.target.files[0]; // Store the selected file
});


function closePopup() {
    document.getElementById('popup').style.display = 'none';
}

document.querySelector(".skip-btn").addEventListener("click", async () => {
    closePopup();
    const file = document.getElementById("csvFile").files[0];
    const uploadArea = document.getElementById("csvUploadForm");
    const progressBar = document.getElementById("upload-progress");
    const progressContainer = document.getElementById("progress-container");
    const progressText = document.getElementById("progress-text");

    if (!file) {
        alert("No file selected.");
        return;
    }

    // Reset and show progress bar
    progressBar.value = 0;
    progressText.textContent = "0%";
    progressContainer.style.display = "block";

    let artificialProgress = 0;
    let progressInterval;

    // Function to simulate progress
    const simulateProgress = () => {
        if (artificialProgress < 90) {
            const increment = Math.random() * 3 + 1;
            artificialProgress = Math.min(artificialProgress + increment, 90);
            
            progressBar.value = artificialProgress;
            progressText.textContent = `${Math.round(artificialProgress)}%`;
        }
    };

    try {
        const formData = new FormData();
        formData.append("csvFile", file);
        formData.append("skip", "true");

        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();

            // Start progress simulation
            progressInterval = setInterval(simulateProgress, 200);

            xhr.upload.addEventListener("progress", (event) => {
                if (event.lengthComputable) {
                    // Clear simulated progress if we get actual progress
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }

                    const actualProgress = Math.min(Math.round((event.loaded / event.total) * 100), 99);
                    
                    if (actualProgress > artificialProgress) {
                        artificialProgress = actualProgress;
                        progressBar.value = artificialProgress;
                        progressText.textContent = `${artificialProgress}%`;
                    }
                }
            });

            xhr.addEventListener("load", async () => {
                // Clear interval if it's still running
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }

                try {
                    const response = JSON.parse(xhr.responseText);

                    // Show 100% completion
                    progressBar.value = 100;
                    progressText.textContent = "100%";

                    setTimeout(() => {
                        progressContainer.style.display = "none";
                        showFlashMessage(response.message || "Batch upload completed with skipped invalid rows.", "success");
                            function showFlashMessage(message, type = "success") {
                            const flashMessage = document.createElement("div");
                            flashMessage.className = `flash-message ${type}`;
                            flashMessage.innerHTML = message;

                            document.body.appendChild(flashMessage);

                            // Automatically remove flash message after 5 seconds
                            setTimeout(() => {
                                flashMessage.remove();
                            }, 3000);
                        }

                    }, 500);

                    resolve(response);
                } catch (error) {
                    progressContainer.style.display = "none";
                    alert("Error in server response.");
                    reject(error);
                }
            });

            xhr.addEventListener("error", () => {
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
                progressContainer.style.display = "none";
                alert("An error occurred during file upload.");
                reject(new Error("Upload failed"));
            });

            xhr.addEventListener("abort", () => {
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
                progressContainer.style.display = "none";
                alert("File upload was canceled.");
                reject(new Error("Upload aborted"));
            });

            // Send the request
            xhr.open("POST", "/staff/data-entry/upload", true);
            xhr.send(formData);
        });

    } catch (error) {
        if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
        }
        console.error("Error during upload:", error);
        progressContainer.style.display = "none";
        alert("An error occurred while uploading.");
    }
});

const cancelButton = document.getElementById("cancelButton");    
    let isCancelled = false; // Track if the user clicks "Cancel"
    // "Cancel" button logic
    cancelButton.addEventListener("click", () => {
        closePopup();
        isCancelled = true; // Mark the upload process as cancelled
        showFlashMessage("Batch upload terminated!", "error");
        function showFlashMessage(message, type = "success") {
    const flashMessage = document.createElement("div");
    flashMessage.className = `flash-error-message ${type}`;
    flashMessage.innerHTML = message;

    document.body.appendChild(flashMessage);

    // Automatically remove flash message after 5 seconds
    setTimeout(() => {
        flashMessage.remove();
    }, 3000);
}
    });

</script> 

<script>
    // Global variable to store current missing data rows displayed in the popup
    let currentMissingDataRows = [];
    let downloadCount = 0; // Counter for downloads
    const maxDownloads = 20; // Maximum allowed downloads

    function showPopup(missingDataRows) {
        // Save the rows for download
        currentMissingDataRows = missingDataRows;

        // Get the table body element
        const tableBody = document.getElementById("missing-fields-table");

        // Clear previous content
        tableBody.innerHTML = "";

        // Dynamically add rows with missing data
        missingDataRows.forEach(row => {
            const tableRow = document.createElement("tr");

            // Add Row Number column
            const rowNumberCell = document.createElement("td");
            rowNumberCell.textContent = row.rowNumber;
            tableRow.appendChild(rowNumberCell);

            // Add remaining fields dynamically and highlight missing fields
            ["Mr_no", "firstName", "lastName", "DOB", "datetime","speciality", "doctorId", "phoneNumber"].forEach(field => {
                const cell = document.createElement("td");

                if (!row[field] || row[field] === "Missing") {
                    // If the field is missing, highlight it
                    cell.textContent = "Missing";
                    cell.classList.add("missing-field");
                } else {
                    cell.textContent = row[field];
                }
                tableRow.appendChild(cell);
            });

            // Append the row to the table body
            tableBody.appendChild(tableRow);
        });

        // Show the popup
        const popup = document.getElementById("popup");
        popup.style.display = "block";
    }

    // Function to show flash messages
    function showFlashMessage(message, type = 'success') {
        const flashMessageContainer = document.getElementById('flashMessageContainer');
        flashMessageContainer.textContent = message;

        // Set the background color based on the message type
        flashMessageContainer.style.backgroundColor = type === 'success' ? '#4CAF50' : '#f44336';

        // Show the flash message
        flashMessageContainer.style.display = 'block';

        // Hide the flash message after 2 seconds
        setTimeout(() => {
            flashMessageContainer.style.display = 'none';
        }, 5000);
    }

    // Function to download the missing data rows as a CSV
    function downloadMissingData() {
        if (downloadCount >= maxDownloads) {
            showFlashMessage('Maximum download limit reached. No further downloads are allowed.', 'error');
            return;
        }

        if (!currentMissingDataRows.length) {
            showFlashMessage('No missing data available for download.', 'error');
            return;
        }

        // Increment the download counter
        downloadCount++;

        // Define the desired fields for the CSV
        const desiredFields = ["Mr_no", "firstName", "lastName", "DOB", "datetime", "speciality", "doctorId", "phoneNumber"];

        // Create CSV headers based on the desired fields
        const headers = desiredFields;

        // Create CSV content
        const csvContent = [
            headers.join(','), // Add headers as the first row
            ...currentMissingDataRows.map(row =>
                headers.map(header => {
                    // Replace 'Missing' or null/undefined values with an empty string
                    const value = row[header];
                    return value === null || value === undefined || value === "Missing" ? '' : value;
                }).join(',')
            )
        ].join('\n'); // Join all rows with a newline character

        // Create a Blob from the CSV content
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);

        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = 'missing_data.csv'; // Set the file name
        document.body.appendChild(a);
        a.click(); // Trigger the download
        a.remove(); // Remove the element after download

        // Clean up the Blob URL
        window.URL.revokeObjectURL(url);

        // Show a success flash message
        if (downloadCount < maxDownloads) {
            showFlashMessage("Download successful.");
         } 
         if(downloadCount > maxDownloads) {
            showFlashMessage('Maximum download limit reached. No further downloads are allowed.', 'error');
         }
    }

    // Attach the download functionality to the download button
    document.getElementById("downloadCSVButton").addEventListener("click", downloadMissingData);
</script>
<!-- 
<script>
    // Function to pad single-digit values with leading zero
function padToTwoDigits(value) {
    return value.toString().padStart(2, '0');
}

// Normalize date (MM/DD/YYYY)
const [month, day, year] = date.split('/');
const normalizedDate = `${padToTwoDigits(month)}/${padToTwoDigits(day)}/${year}`;

// Combine normalized date and time
const combinedDatetime = `${normalizedDate} ${time}`;

// Parse the combined datetime into a Date object
const formattedDatetime = new Date(combinedDatetime);
</script> -->

</body>
</html>